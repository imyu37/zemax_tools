# -*- coding: utf-8 -*-
"""
Created on Wed Aug 23 15:06:46 2017

Opens strehl ratio maps generated by Zemax.

Can hightlight area with strehl ratio larger than a certain value and produce
a nice plot summarizing this.

@author: pag227
"""
import os
import numpy as np
import matplotlib
#matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors
import pandas as pd
import GrasPy
from matplotlib.patches import Circle, RegularPolygon
import matplotlib.path
import itertools
import re


        

def makeColorMap(limit):
    colors1 = cm.binary(np.linspace(0,1,256*limit))
    colors2 = cm.viridis(np.linspace(0,1,256*(1-limit)))
    colors=np.vstack((colors1, colors2))
    mymap = mcolors.LinearSegmentedColormap.from_list('my_colormap', colors)
    return mymap

def maskHexagon(hex_vert, xx,yy):
    '''Receives two 2d vectors, xx and yy. Returns a binary mask with the same 
    shape. The mask is true when the x,y coordinate is inside the borders, 
    False ioc.'''
    XY = np.dstack((xx,yy))
    XY_flat = XY.reshape((-1,2))
    hex_path = hexPath(hex_vert)
    masked = hex_path.contains_points(XY_flat)
    masked = masked.reshape(np.shape(xx))
    return masked

def hexPath(vertices):
    '''Makes a path object with the given vertices of the hexagon'''
    vertices.append([0.0 , 0.0])
    codes = ([matplotlib.path.Path.MOVETO] + 
             [matplotlib.path.Path.LINETO]*5 + 
             [matplotlib.path.Path.CLOSEPOLY])
    return matplotlib.path.Path(vertices, codes)

def hexVert(center, radius, orientation=np.pi/2.):
    '''Returns the vertices of n hexagon using the same syntax as matplotlib.'''
    orientation = orientation - np.pi/2.
    vertices = []
    for j in range(6):
        vertices.append([center[0] + radius * np.cos(2.*np.pi*j/6.+orientation), 
                         center[1] + radius * np.sin(2.*np.pi*j/6.+orientation)])
    return vertices

class layout():
    def __init__(self, 
                 R_wafer=68.75, 
                 R_detPlane=138.0, 
                 plot=True,
                 show=True,
                 pointUp=True):
        '''This class contains the information needed to generate the detector
        layout in the focal plane. Units are all in mm.
        Centers: 2xn coordinates of the centers of the wafers. n is the number of
        hexagons in the layout
        R_wafer: radius of the circle which has the hexagon inscribed
        R_detPlane: Radius of the focal plane.'''
        if pointUp: # orientation of the tip of the triangle between centers of hexes
            firstCenterAngle = np.pi/2
        else:
            firstCenterAngle = -np.pi/2
        centers =  [[R_wafer*np.cos(t),R_wafer*np.sin(t)] 
                    for t in firstCenterAngle + np.arange(0,3)*2*np.pi/3]
        self.centers = centers
        self.R_wafer = R_wafer #radius of an individual hexagon
        self.R_detPlane = R_detPlane #radius of the focal plane
        
        if plot:
            fig = plt.figure(figsize=(8,8))
            ax = plt.subplot(aspect='equal')
        
        hexagons = []
        hex_verts = []
        for j in range(len(centers)):
            hexagon = RegularPolygon(centers[j], 6, 
                                     radius=R_wafer, 
                                     orientation=0.0, 
                                     fill=False,
                                     lw=2)
            hexagons.append(hexagon)
            hex_verts.append( hexVert(centers[j], R_wafer, orientation=0)  )
            if plot:
                ax.add_artist(hexagon)
            
        circle = Circle([0,0], 
                        R_detPlane, 
                        fill=False, 
                        lw=2, 
                        ls='dashed')
        if plot:
            ax.add_artist(circle)
        
            plt.xlim([-R_detPlane*1.05, R_detPlane*1.05])
            plt.ylim([-R_detPlane*1.05, R_detPlane*1.05])
            if show:
                plt.show()
            else:
                plt.savefig('layout.png')
                plt.savefig('layout.pdf')
                plt.close()
        self.hexagons = hexagons
        self.circle = circle
        self.hex_verts = hex_verts
    

def makeLevels(strehlMap, levelMin, levelMax):
    '''If there are values between levelMin and Max, do it.
    If there isnt, go from 0 to level Max'''
    if (strehlMap > levelMin).sum() > 0:
        levelMax = strehlMap.max()
        levels = np.arange(levelMin, levelMax, 0.05)
    else:
        levels = np.arange(strehlMap.min(), strehlMap.max(), 0.05)[1:-1]
    print(levels)
    return levels

class strehlMap():
    def __init__(self, fname, field = [0.7,0.7], degToMM=1/0.7*133.0, invertSign=True):
        '''Opens the file specified by fname, field contains a
        vector with the semi diameter of the field contained in the file.
        The strehl map needs to be generated by Zemax.
        
        invertSign is set to true if you are going from deg in the sky to mm in the focal plane'''
        if invertSign:
            degToMM = -1.0 * degToMM
        self.fname = fname
        self.title = fname.split('.txt')[0]
        df = pd.read_csv(fname, 
                         skiprows=16, 
                         encoding='utf_16_le', 
                         delim_whitespace=True, 
                         header=None)
        self.StrehlMap = df.values
        [Nx, Ny] = np.shape(self.StrehlMap)
        x = np.linspace(-field[0], field[0], Nx)
        y = np.linspace(field[1], -field[1], Ny) #from plus to minus top to bottom
        xx, yy = np.meshgrid(x,y)
        self.xx, self.yy = xx, yy
        self.xx_mm, self.yy_mm = xx*degToMM, yy*degToMM
        self.extent = [-field[0], field[0], -field[1], field[1]]
        self.extent_mm = np.array(self.extent) * degToMM
        
        self.levels = makeLevels(self.StrehlMap, 0.7, 0.99)
    
    def plotHist_maskedRegion(self):
        '''Plots histogram of the strehl Map with the array coverage area 
        masked and the image quality area greater than limit'''

        data = self.StrehlMap[ self.mask_hex ].flatten()
        median = np.median(data)
        data_m = np.percentile(data, 15.9)
        sigma_m = median - data_m
        data_p = np.percentile(data, 84.1)
        sigma_p = data_p - median

        plt.figtext(0.7, 0.7, 
                    "$\mu$=%1.2f\n$\sigma_-$=%1.2f\n$\sigma_+$=%1.2f"
                    %(median, sigma_m, sigma_p))
        
        if not os.path.exists("hists"):
            os.makedirs("hists")
        
        plt.hist(data)

        plt.axvline(median, color = 'black')
        plt.axvline(data_p, color = 'grey')
        plt.axvline(data_m, color = 'grey')

        plt.title("Strehl Ratio over focal plane")
        plt.xlabel('Strehl Ratio')
        plt.ylabel('N')



        plt.savefig("hists/" + self.fname.split(".")[0] + ".png")
        plt.close()


    def plotMap(self, show=True):
        '''plots strehl ratio surface followign example in:
            https://matplotlib.org/examples/pylab_examples/contour_demo.html'''
        extent = self.extent
        levels = self.levels
        plt.figure()
        plt.title(self.fname.split('.txt')[0])
        im = plt.imshow(self.StrehlMap, 
                   vmin=0, 
                   vmax=1.0, 
                   origin='upper', 
                   cmap=cm.inferno,
                   extent=extent )
        CS = plt.contour(self.xx, 
                         self.yy, 
                         self.StrehlMap,
                         levels,
                         cmap=cm.viridis,
                         linewidths=2,
                         extent=extent)
        plt.clabel(CS, levels, inline=1, fmt='%1.2f', fontsize=14)
        plt.xlabel('X-field [deg]')
        plt.ylabel('Y-field [deg]')
        plt.colorbar(im, 
                     label='Strehl Ratio [-]',
                     shrink=0.7)
        GrasPy.signPlot()
        if show:
            plt.show()
        else:
            plt.savefig('imageQuality_%s.png'%self.title)
            plt.savefig('imageQuality_%s.pdf'%self.title)
            plt.close()
    
    def strehlGreaterThan(self, limit=0.8, show=True):
        '''Plots the StrehlMaps generated by Zemax and stored as text files
        Selects the fraction of the data with Strehl greater than limit.
        Saves the plot in the current folder.'''
        extent = self.extent
        levels = self.levels
        ###get the fraction that matches the criterium
        mask = np.ma.masked_where(self.StrehlMap < limit, self.StrehlMap)
        N = mask.count()
        fraction_pct = 100.0 * float(N)/len(self.StrehlMap.flatten())
        self.fraction_pct = fraction_pct
        
        #make a custom colormap to color the plot
        
        mymap = makeColorMap(limit)
        
        plt.figure(figsize=[6,5])
        ax = plt.subplot(aspect='equal')

        plt.title(self.fname.split('.txt')[0])
        im = plt.imshow(self.StrehlMap,
                        origin='upper',
                        cmap=mymap,
                        vmin = 0,
                        vmax = 1,
                        extent=extent)
        CS = plt.contour(self.xx, self.yy, self.StrehlMap,
                         levels,
                         cmap=cm.Oranges,
                         linewidths=2,
                         extent=extent)
        plt.clabel(CS, levels, inline=1, fmt='%1.2f', fontsize=14)
        
        plt.xticks(np.arange(extent[0], extent[1]+0.1, 0.2) )
        plt.yticks(np.arange(extent[2], extent[3]+0.1, 0.2))
        plt.grid(alpha = 0.3)
        plt.colorbar(im, 
                     ticks=np.append(np.linspace(0,1,11), limit),
                     shrink=0.7)
        
        #plt.text(0.23, -0.65, 
        #         '$A_{>%1.1f}$ = %1.1f %%' %(limit, fraction_pct),
        #         fontsize=12,
        #         bbox=dict(boxstyle='round', fc='w'))
        plt.xlabel('X field [deg]')
        plt.ylabel('Y field [deg]')
        plt.tight_layout()
        
        GrasPy.signPlot()
        if show:
            plt.show()
        else:
            ending=('_StrehlLimit%1.1f'%(limit)).replace('.','p')
            plt.savefig('%s%s.png'%(self.title, ending), dpi=300)
            plt.savefig('%s%s.pdf'%(self.title, ending), dpi=300)
            plt.close()

    def strehlAndLayout(self, limit=0.8, show=True, pdf=True, shortTitle=False,
                        R_wafer=69.7, R_detPlane=139.4, pointUp=True):
        '''Makes footprint diagram of the focal plane overlayed with
        points that fulfill the strehl>limit condition.
        shorTitle: flag that was added for the SPIE paper plots, defaults to False for usual plots'''
        if shortTitle: #chooses the correct title and wavelength
            currentFname = self.fname.split(".txt")[0]
            m = re.match(".*Conf_([0-9]*)_wavelength_([0-9]*).*", currentFname)
            confNumber = int(m.group(1))
            wavelength = int(m.group(2))
            title = "Configuration %i, $\lambda$=%i $\mu$m"%(confNumber, wavelength)

        levels = self.levels
        extent = self.extent_mm
        lay = layout(plot=False, R_wafer=R_wafer, R_detPlane=R_detPlane, pointUp=pointUp)
        
        hex_verts = lay.hex_verts # get the array layout mask
        xx, yy = self.xx_mm, self.yy_mm
        N = len(hex_verts)
        hex_masks = list(map(maskHexagon, 
                        hex_verts,
                        itertools.repeat(xx, N),
                        itertools.repeat(yy, N) ))
        hex_mask = hex_masks[0]
        for j in range(len(hex_masks)):
            hex_mask = np.logical_or(hex_mask, hex_masks[j])
        self.mask_hex = hex_mask
        
        strehlMask = self.StrehlMap > limit #strehl ratio mask
        
        mask_strehl_and_Layout = np.logical_and(strehlMask, 
                              hex_mask )
        self.masked_Strehl_OverLimit_withLayout = mask_strehl_and_Layout
        self.mask_strehl_and_Layout = mask_strehl_and_Layout
        masked_imgQual_andLayout = np.ma.masked_where(np.logical_not(mask_strehl_and_Layout), self.StrehlMap)
        masked_imgQual_noLayout = np.ma.masked_where(np.logical_not(hex_mask), self.StrehlMap)
        imgToShow = masked_imgQual_noLayout
        
        plt.figure(figsize=[6,5])
        ax = plt.subplot(aspect='equal')
        for j in range(len(lay.hexagons)):
            ax.add_artist(lay.hexagons[j])
        ax.add_artist(lay.circle)
        
        mymap = makeColorMap(limit)
        im = plt.imshow(imgToShow, 
                        extent=extent, 
                        vmin=0.0,
                        vmax=1.0,
                        cmap=mymap, 
                        origin='upper',
                        label='Strehl Ratio [-]')
        #if (self.StrehlMap > min(levels)).sum() > 0:
            #put contours
        #    levels = np.arange(min(levels), self.StrehlMap.max(), 0.05)
        #    print levels

        CS = plt.contour(self.xx_mm, self.yy_mm, self.StrehlMap,
                         levels,
                         cmap=cm.Oranges,
                         linewidths=2,
                         extent=extent,
                         vmin=0.5,
                         vmax=1)
        plt.clabel(CS, levels, inline=1, fmt='%1.2f', fontsize=14)

        #else:
        #    print "warning: no values to show contours..."

        if shortTitle and (confNumber == 3):
            cb = plt.colorbar(im, shrink = 0.7)
            cb.set_label('Strehl Ratio [-]', fontsize = 20)
            cb.ax.tick_params(labelsize=15) 

        if not shortTitle:
            cb = plt.colorbar(im, shrink = 0.7)
            cb.set_label('Strehl Ratio [-]')

        plt.xlim(lay.R_detPlane*np.array([-1.05,1.05]))
        plt.ylim(lay.R_detPlane*np.array([-1.05,1.05]))
#        plt.show()
        
        if shortTitle:
            for tick in ax.xaxis.get_major_ticks():
                tick.label.set_fontsize('x-large')
            for tick in ax.yaxis.get_major_ticks():
                tick.label.set_fontsize('x-large')

        Area_inLayout_and_greaterThanLmit = 1.0*np.sum(
                mask_strehl_and_Layout)/(np.sum(hex_mask))
        if shortTitle:
            fontsize=15
        else:
            fontsize=12
        plt.text(-130, 120, 
                 '$A_{>%1.1f & in Layout}$ = %1.1f %%' %(limit, 100*Area_inLayout_and_greaterThanLmit),
                 fontsize=fontsize,
                 bbox=dict(boxstyle='round', fc='w', alpha=0.7),
                 zorder=10)
        plt.grid(alpha = 0.3)
        if shortTitle:
            plt.title(title, fontsize = 25)
        else: 
            plt.title('Focal Plane Layout and image quality, strehl>%1.2f \n %s'%(limit,self.title ) )

        if shortTitle:
            plt.xlabel('X [mm]', fontsize='x-large')
            plt.ylabel('Y [mm]', fontsize='x-large')

        else:
            plt.xlabel('X Field [mm]')
            plt.ylabel('Y Field [mm]')
        plt.tight_layout()
        if not shortTitle:
            GrasPy.signPlot()
        if show:
            plt.show()
        else:
            fname = ('imgQual_%s_FocalPlaneLayout_limit_%1.1f'%(self.title, limit)).replace('.',"p")
            plt.savefig(fname + '.png', dpi=450)
            if pdf:
                plt.savefig(fname + '.pdf')
            plt.close()
            
class ArrayAngularCoverage:
    def __init__(self, 
                 field = [0.7,0.7], 
                 degToMM=1/0.7*130.0,
                 angles=[0.5, 0.60, 0.65, 0.7],
                 plot = True, show=True):
        '''Presents the layout of the focal plane unit with a diagram showing
        the circles of iqual distance from the center. The radii of the circles
        are given in vector angles. Field and degToMM present the range of the 
        field of view of interest and the scale from angle to mm in the focal
        plane.'''
        self.lay = layout(R_wafer=68.75, 
                 R_detPlane=135.0, 
                 plot=False,
                 show=False)
        lay = self.lay
        self.field = field
        self.degToMM = degToMM
        self.angles = angles
        
        hex_verts = lay.hex_verts # get the array layout mask
        
        x = np.linspace(-field[0], field[0], 250)
        y = np.linspace(-field[1], field[1], 250)
        xx, yy = np.meshgrid(x,y)
        self.xx, self.yy = xx, yy
        r = np.sqrt(xx**2 + yy**2)
        self.xx_mm, self.yy_mm = xx*degToMM, yy*degToMM
        xx, yy = self.xx_mm, self.yy_mm
        N = len(hex_verts)
        
        hex_masks = map(maskHexagon, 
                        hex_verts,
                        itertools.repeat(xx, N),
                        itertools.repeat(yy,N) )
        hex_mask = hex_masks[0]
        for j in range(len(hex_masks)):
            hex_mask = np.logical_or(hex_mask, hex_masks[j])
        self.mask_hex = hex_mask
        
        self.mask_radii = [r<angles[j] for j in range(len(angles))]
        
        mask_radii_and_hex = [np.logical_and(hex_mask, self.mask_radii[j]) 
                                   for j in range(len(angles))]
        self.mask_radii_and_hex = mask_radii_and_hex
        patchArea = float(np.sum(self.mask_hex.flatten()))
        maskedAreas = np.array([np.sum(mask_radii_and_hex[j].flatten()) 
                       for j in range(len(angles))])
        Areas_pct = maskedAreas/patchArea
        self.Areas_pct = Areas_pct
        extent = np.array([-field[0], field[0], -field[1],field[1]]) * degToMM
        self.extent = extent
        
        if plot:
            plt.figure(figsize=[6,5])
            ax = plt.subplot(aspect='equal')
            for j in range(len(lay.hexagons)):
                ax.add_artist(lay.hexagons[j])
            ax.add_artist(lay.circle)
            
                             
            im = plt.imshow(r, extent=extent)
            plt.xlim(np.array([-field[0], field[0]]) * degToMM*1.05)
            plt.ylim(np.array([-field[1], field[1]]) * degToMM*1.05)
            
            CS = plt.contour(self.xx_mm, self.yy_mm, r,
                         angles,
                         cmap=cm.Oranges,
                         linewidths=2,
                         extent=extent,
                         vmin=0.4,
                         vmax=0.7)
            plt.clabel(CS, angles, inline=1, fmt='%1.2f', fontsize=14)
        
        
            cb = plt.colorbar(im, shrink = 0.7)
            cb.set_label('Angular distance [deg]')
            plt.xlabel('X[mm]')
            plt.ylabel('Y[mm]')
            plt.title('Detector Array Layout and angular fields')
            if show:
                plt.show()
            else:
                plt.savefig('Layout_Angles.png', dpi=350)
                plt.savefig('Layout_Angles.pdf')
                plt.close()
            
    def plotCoverage(self, show=True):
        
        field= self.field
        degToMM = self.degToMM
        xx, yy = self.xx, self.yy
        angles = self.angles
        extent = np.array([-field[0], field[0], -field[1],field[1]]) * degToMM
        for j in range(len(angles)):
            lay = layout(R_wafer=68.75, 
                 R_detPlane=135.0, 
                 plot=False,
                 show=False)
            r = np.sqrt(xx**2 + yy**2)
        
            r_masked = np.ma.masked_where(np.logical_not(self.mask_radii_and_hex[j]), r)
        
            plt.figure(figsize=[6,5])
            ax = plt.subplot(aspect='equal')
            for h in range(len(lay.hexagons)):
                ax.add_artist(lay.hexagons[h])
                ax.add_artist(lay.circle)
                
                im = plt.imshow(r_masked, extent=extent)
        
            CS = plt.contour(self.xx_mm, self.yy_mm, r,
                         angles,
                         cmap=cm.Oranges,
                         linewidths=2,
                         extent=extent,
                         vmin=0.4,
                         vmax=0.7)
            plt.clabel(CS, angles, inline=1, fmt='%1.2f', fontsize=14)
            plt.grid(alpha=0.3)
            
            plt.xlim(np.array([-field[0], field[0]]) * degToMM*1.05)
            plt.ylim(np.array([-field[1], field[1]]) * degToMM*1.05)
            plt.text(0,0, 'Area = %2.2f %%' %(100.0 * self.Areas_pct[j]), 
                 color='white',
                 fontsize=18,
                 ha='center')
            plt.xlabel('X[mm]')
            plt.ylabel('Y[mm]')
            plt.title('Area with FoV < %1.2f' %angles[j])
            if show:
                plt.show()
            else:
                fname = ('AreaWithFovLessThan%1.2f'%angles[j]).replace('.','p')
                plt.savefig(fname + '.png', dpi=350)
                plt.savefig(fname + '.pdf')
                plt.close()
    def plotArea_pct(self, show=True):
        '''Plots how the covered area depends on the fov'''
        plt.plot(self.angles, 100* self.Areas_pct,
                 linestyle = '--')
        plt.scatter(self.angles, 100* self.Areas_pct)
        plt.title('Field of View Area Coverage')
        plt.xlabel('FoV [deg]')
        plt.ylabel('% Array covered')
        plt.grid()
        if show:
            plt.show()
        else:
            plt.savefig('PctAreaCovered.png', dpi=350)
            plt.savefig('PctAreaCovered.pdf')
            plt.close()


